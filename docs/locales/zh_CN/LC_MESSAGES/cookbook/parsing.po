# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: 467195537@qq.com\n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: 2022-07-18 01:34+0000\n"
"Last-Translator: Leo Liu <leo19920823@gmail.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/"
"idris2/cookbookparsing/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.14-dev\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/cookbook/parsing.rst:2 87dbf5c419424138957bc4c8c2967f2f
msgid "Parsing"
msgstr "解析"

#: ../../source/cookbook/parsing.rst:4 8fea0944fea04fc98a4c7890b5451f1b
msgid ""
"Idris 2 comes with a Lexing and a Parsing library built into the "
"``contrib`` package."
msgstr "Idris 2 带有一个 Lexing 库和 Parsing库，内置在 ``contrib`` 包中。"

#: ../../source/cookbook/parsing.rst:6 f52d389ed3a4424da8e371edeeacfa13
msgid ""
"For this cookbook, we will write a very simple parser for a lambda "
"calculus parser that will accept the following language:"
msgstr "在这本食谱中，我们将写一个非常简单的 lambda calculus "
"解析器，该解析器将接受以下语言："

#: ../../source/cookbook/parsing.rst:13 dbb7d82b692945059bd1dbfcf011b763
msgid ""
"Once we write a lambda calculus parser, we will also see how we can take "
"advantage of a powerful built in expression parser in Idris 2 to write a "
"small calculator that should be smart enough to parse the following "
"expression:"
msgstr ""
"一旦我们写了一个 lambda calculus 解析器，我们还将看到我们如何利用 Idris 2 "
"中强大的内置表达式解析器来写一个小计算器，它应该足够聪明来解析以下表达式："

#: ../../source/cookbook/parsing.rst:22 df3af786b87f4fa8821e3ae5261b7046
msgid "Lexer"
msgstr "词法分析器"

#: ../../source/cookbook/parsing.rst:24 de406a0c0d8e4fe4af551eab21d6bfbc
msgid ""
"The main lexer module is under ``Text.Lexer``. This module contains "
"``toTokenMap`` which is a function that converts a ``List (Lexer, k) -> "
"TokenMap (Token k)`` where ``k`` is a token kind. This function could be "
"used for simple lexer to token mappings. The module also includes high "
"level lexers for specifying quantity and common programming primitives "
"like ``alphas``, ``intLit``, ``lineComment`` and ``blockComment``."
msgstr ""
"词法模块主要在 ``Text.Lexer`` 下。这个模块包含 ``toTokenMap`` ，这是一个转换 "
"``List (Lexer, k) -> TokenMap (Token k)`` 的函数，其中 ``k`` 是一个标记种类。"
"这个函数可用于简单的词法与标记的映射。该模块还包括高级词法，用于指定数量和常"
"见的编程基元，如 ``alphas`` , ``intLit``, ``lineComment`` 和 ``blockComment``"
" 。"

#: ../../source/cookbook/parsing.rst:30 19327f1a741941b5bef8f1d6cd21f503
msgid ""
"The ``Text.Lexer`` module also reexports ``Text.Lexer.Core``, "
"``Text.Quantity`` and ``Text.Token``."
msgstr ""
"``Text.Lexer`` 模块还重新导出了 ``Text.Lexer.Core`` 、 ``Text.Quantity`` 和 "
"``Text.Token`` 。"

#: ../../source/cookbook/parsing.rst:32 6777ab649fd74820b24dd3ecdea5c68e
msgid ""
"``Text.Lexer.Core`` provides the building blocks of the lexer, including "
"a type called ``Recognise`` which is the underlying data type for the "
"lexer. The other important function that this module provides is a "
"``lex`` which takes in a lexer and returns the tokens."
msgstr ""
"``Text.Lexer.Core`` 提供了词法的构建块，包括一个叫做 ``Recognise`` "
"的类型，它是词法的底层数据类型。这个模块提供的另一个重要功能是 ``lex`` ，"
"它接收一个词法分析器并返回 token。"

#: ../../source/cookbook/parsing.rst:36 7a7e212aae7a4459b39e8fcccf790239
msgid ""
"``Text.Quantity`` provides a data type ``Quantity`` which can be used "
"with certain lexers to specify how many times something is expected to "
"appear."
msgstr "``Text.Quantity`` 提供了一个数据类型 ``Quantity`` "
"可以与某些词典一起使用，以指定某些东西预计会出现多少次。"

#: ../../source/cookbook/parsing.rst:39 fd1c3a0dd7114b6cad709d4492fd527c
msgid ""
"``Text.Token`` provides a data type ``Token`` that represents a parsed "
"token, its kind and the text. This module also provides an important "
"interface called ``TokenKind`` which tells the lexer how to map token "
"kinds to Idris 2 types and how to convert each kind from a string to a "
"value."
msgstr ""
"``Text.Token`` 提供一个数据类型 ``Token`` "
"表示一个被解析的标记和它的种类，或者文本。这个模块还提供了一个重要的接口，"
"称为 ``TokenKind``.，它告诉词法分析器如何将标记种类映射到 Idris 2 "
"类型，以及如何将每种种类从字符串转换为一个值。"

#: ../../source/cookbook/parsing.rst:44 fe65ace636dd4ba9b5194d221f464a02
msgid "Parser"
msgstr "解析器"

#: ../../source/cookbook/parsing.rst:46 4c0aa1035a8a414c82313187af2f0d7c
msgid ""
"The main parser module is under ``Text.Parser``. This module contains "
"different grammar parsers, the main one being ``match`` which takes a "
"``TokenKind`` and returns the value as defined in the ``TokenKind`` "
"interface. There are other grammar parsers as well, but for our example, "
"we will only be using ``match``."
msgstr ""
"解析器模主要在 ``Text.Parser`` 下。这个模块包含不同的语法分析器，"
"主要的语法分析器是 ``match`` 它接收一个 ``TokenKind`` 并返回 ``TokenKind`` "
"接口中定义的值。还有其他的语法分析器，但对于我们的例子，我们将只使用 "
"``match`` 。"

#: ../../source/cookbook/parsing.rst:50 b43d7d9dc97c4a1c8114d7e56d4047c2
msgid ""
"The ``Text.Parser`` module reexports ``Text.Parser.Core``, "
"``Text.Quantity`` and ``Text.Token``."
msgstr ""
"``Text.Parser`` 模块重新导出 ``Text.Parser.Core`` , ``Text.Quantity`` 和 "
"``Text.Token`` 。"

#: ../../source/cookbook/parsing.rst:52 4ae8ca4b8c9744e2be40c2aa12ba38e5
msgid ""
"``Text.Parser.Core`` provides the building blocks of the parser, "
"including a type called ``Grammar`` which is the underlying data type for"
" the parser. The other important function that this module provides is "
"``parse`` which takes in a ``Grammar`` and returns the parsed expression."
msgstr ""
"``Text.Parser.Core`` 提供了解析器的构建块，包括一个叫做 ``Grammar`` "
"的类型，它是解析器的底层数据类型。这个模块提供的另一个重要函数是 ``parse`` "
"它接收一个 ``Grammar`` 并返回解析后的表达式。"

#: ../../source/cookbook/parsing.rst:56 be85bf8a8ed147b7b57a7190f71dac9c
msgid ""
"We covered ``Text.Quantity`` and ``Text.Token`` in the Lexer section so "
"we're not going to repeat what they do here."
msgstr "我们在 Lexer 部分介绍了 ``Text.Quantity`` 和 ``Text.Token`` "
"，所以我们不打算在这里重复它们的作用。"

#: ../../source/cookbook/parsing.rst:60 1bba6428a6a54fa2ba708f8631888784
msgid "Lambda Calculus Lexer & Parser"
msgstr "Lambda 演算的分析器和解析器"

#: ../../source/cookbook/parsing.rst:62 4025d13075ad422a90fc8376db3eafe4
msgid "LambdaCalculus.idr"
msgstr "LambdaCalculus.idr"

#: ../../source/cookbook/parsing.rst:231 f3ffa5ef7f1a4a9a92db2b0071758a8d
msgid "Testing out our parser gives us back the following output:"
msgstr "测试一下我们的分析器，得到的输出结果如下："

#: ../../source/cookbook/parsing.rst:240 2036059fbe6d458481fa18a66cd8ec1e
msgid "Expression Parser"
msgstr "表达式解析器"

#: ../../source/cookbook/parsing.rst:242 1792edb69d814b429c3f89df5731a4c3
msgid ""
"Idris 2 also comes with a very convenient expression parser that is aware"
" of precedence and associativity in ``Text.Parser.Expression``."
msgstr "Idris 2 还在 ``Text.Parser.Expression`` "
"中配备了一个非常方便的表达式解析器，可以明确优先权和关联性。"

#: ../../source/cookbook/parsing.rst:245 cb11729c8b454462b2bbea6198380b6d
msgid ""
"The main function called ``buildExpressionParser`` takes in an "
"``OperatorTable`` and a ``Grammar`` that represents the terms, and "
"returns a parsed expression. The magic comes from the ``OperatorTable`` "
"since this table defines all the operators, the grammars for those "
"operators, the precedence, and the associativity."
msgstr ""
"名为 ``buildExpressionParser`` 的主函数接受一个 ``OperatorTable`` "
"和一个表示术语的 ``Grammar`` ，并返回一个解析后的表达式。魔法来自 "
"``OperatorTable`` ，因为该表定义了所有运算符及其语法、优先级和关联性。"

#: ../../source/cookbook/parsing.rst:250 5723defd1b2c425d8107dfab71abe832
msgid ""
"An ``OperatorTable`` is a list of lists containing the ``Op`` type. The "
"``Op`` type allows you to specify ``Prefix``, ``Postfix``, and ``Infix`` "
"operators along with their grammars. ``Infix`` also contains the "
"associativity called ``Assoc`` which can specify left associativity or "
"``AssocLeft``, right associativity assoc or ``AssocRight`` and as being "
"non-associative or ``AssocNone``."
msgstr ""
"一个 ``OperatorTable`` 是一个包含 ``Op`` 类型的列表。 ``Op`` 类型允许你指定 "
"``Prefix``, ``Postfix``, 和 ``Infix`` 运算符以及它们的语法。 ``Infix`` "
"也包含了名为 ``Assoc`` 的关联性，可以指定左关联性 ``AssocLeft`` ，右关联性 "
"``AssocRight`` ，以及非关联性 ``AssocNone`` 。"

#: ../../source/cookbook/parsing.rst:255 097b4a7d186145da9b1ab4756712070b
msgid "An example of an operator table we'll be using for the calculator is:"
msgstr "我们将在计算器中使用的运算符表的一个例子是："

#: ../../source/cookbook/parsing.rst:268 9fab47d3ef76496fa13507254c3a7535
msgid ""
"This table defines 4 operators for mulitiplication, division, addition "
"and subtraction. Mulitiplication and division show up in the first table "
"because they have higher precedence than addition and subtraction, which "
"show up in the second table. We're also defining them as infix operators,"
" with a specific grammar and all being left associative via "
"``AssocLeft``."
msgstr ""
"这张表定义了4个运算符，用于乘法、除法、加法和减法。乘法和除法出现在第一个表中"
"，因为它们的优先级高于加法和减法，后者出现在第二个表中。我们还将它们定义为 "
"infix 运算符，有一个特定的语法，并且都是通过 ``AssocLeft`` 进行左关联。"

#: ../../source/cookbook/parsing.rst:274 87f2a83e2df64e118f2865cddcc5576b
msgid "Building a Calculator"
msgstr "构建一个计算器"

#: ../../source/cookbook/parsing.rst:276 71fdc0b0cd4a405ebd47db62f9c061a9
msgid "Calculator.idr"
msgstr "Calculator.idr"

#: ../../source/cookbook/parsing.rst:388 7f40e8eb00844a4d84a6ec90a903fe53
msgid "Testing out our calculator gives us back the following output:"
msgstr "测试一下我们的计算器，就可以得到以下输出："
